% Tests locations of acrylic board locations % Test summary:% 1. Fetch critical locations from acrylic board% 2. Move robot to position to positionarm = openManipX();trajectoryLib = trajectoryLib();position_control_mode(arm);toggle_torque(arm, 1);set_all_servo_speed_limits(arm, 35);% Step 1: Get coordinates[P_X, P_Y, P_Z] = trajectoryLib.get_board_location(3, 1);fprintf('Test Log: X: %.4f - Y: %.4f - Z: %.4f \n', P_X, P_Y, P_Z);P_Z = 0.0300;% Step 1: Convert to angles and write to servo[SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4] = trajectoryLib.IK_with_PHI(P_X, P_Y, P_Z, 0);fprintf('Test Log: Theta 1(Deg): %.4f - Theta 2(Deg): %.4f - Theta 3(Deg): %.4f - Theta 4(Deg): %.4f\n', typecast(uint32(SERVO_THETA_1), 'int32'), typecast(uint32(SERVO_THETA_2), 'int32'), typecast(uint32(SERVO_THETA_3), 'int32'), typecast(uint32(SERVO_THETA_4), 'int32'));write_angles_to_all_servos(arm, SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4);pause(4);% Step 2: Get coordinates[P_X, P_Y, P_Z] = trajectoryLib.get_board_location(12, 1);fprintf('Test Log: X: %.4f - Y: %.4f - Z: %.4f \n', P_X, P_Y, P_Z);P_Z = 0.0300;% Step 2: Convert to angles and write to servo[SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4] = trajectoryLib.IK_with_PHI(P_X, P_Y, P_Z, 0);fprintf('Test Log: Theta 1(Deg): %.4f - Theta 2(Deg): %.4f - Theta 3(Deg): %.4f - Theta 4(Deg): %.4f\n', typecast(uint32(SERVO_THETA_1), 'int32'), typecast(uint32(SERVO_THETA_2), 'int32'), typecast(uint32(SERVO_THETA_3), 'int32'), typecast(uint32(SERVO_THETA_4), 'int32'));write_angles_to_all_servos(arm, SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4);pause(4);% Step 3: Get coordinates[P_X, P_Y, P_Z] = trajectoryLib.get_board_location(12, 9);fprintf('Test Log: X: %.4f - Y: %.4f - Z: %.4f \n', P_X, P_Y, P_Z);P_Z = 0.0300;% Step 3: Convert to angles and write to servo[SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4] = trajectoryLib.IK_with_PHI(P_X, P_Y, P_Z, 0);fprintf('Test Log: Theta 1(Deg): %.4f - Theta 2(Deg): %.4f - Theta 3(Deg): %.4f - Theta 4(Deg): %.4f\n', typecast(uint32(SERVO_THETA_1), 'int32'), typecast(uint32(SERVO_THETA_2), 'int32'), typecast(uint32(SERVO_THETA_3), 'int32'), typecast(uint32(SERVO_THETA_4), 'int32'));write_angles_to_all_servos(arm, SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4);pause(4);% Step 4: Get coordinates[P_X, P_Y, P_Z] = trajectoryLib.get_board_location(12, 17);P_Z = 0.0300;fprintf('Test Log: X: %.4f - Y: %.4f - Z: %.4f \n', P_X, P_Y, P_Z);% Step 4: Convert to angles and write to servo[SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4] = trajectoryLib.IK_with_PHI(P_X, P_Y, P_Z, 0);fprintf('Test Log: Theta 1(Deg): %.4f - Theta 2(Deg): %.4f - Theta 3(Deg): %.4f - Theta 4(Deg): %.4f\n', typecast(uint32(SERVO_THETA_1), 'int32'), typecast(uint32(SERVO_THETA_2), 'int32'), typecast(uint32(SERVO_THETA_3), 'int32'), typecast(uint32(SERVO_THETA_4), 'int32'));write_angles_to_all_servos(arm, SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4);pause(4);% Step 5: Get coordinates[P_X, P_Y, P_Z] = trajectoryLib.get_board_location(3, 17);P_Z = 0.0300;fprintf('Test Log: X: %.4f - Y: %.4f - Z: %.4f \n', P_X, P_Y, P_Z);% Step 5: Convert to angles and write to servo[SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4] = trajectoryLib.IK_with_PHI(P_X, P_Y, P_Z, 0);fprintf('Test Log: Theta 1(Deg): %.4f - Theta 2(Deg): %.4f - Theta 3(Deg): %.4f - Theta 4(Deg): %.4f\n', typecast(uint32(SERVO_THETA_1), 'int32'), typecast(uint32(SERVO_THETA_2), 'int32'), typecast(uint32(SERVO_THETA_3), 'int32'), typecast(uint32(SERVO_THETA_4), 'int32'));write_angles_to_all_servos(arm, SERVO_THETA_1, SERVO_THETA_2, SERVO_THETA_3, SERVO_THETA_4);pause(4);delete(arm);